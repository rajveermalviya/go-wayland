// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/d10d18f3d49374d2e3eb96d63511f32795aab5f7/unstable/text-input/text-input-unstable-v3.xml
//
// TextInputUnstableV3 Protocol Copyright:
//
// Copyright © 2012, 2013 Intel Corporation
// Copyright © 2015, 2016 Jan Arne Petersen
// Copyright © 2017, 2018 Red Hat, Inc.
// Copyright © 2018       Purism SPC
//
// Permission to use, copy, modify, distribute, and sell this
// software and its documentation for any purpose is hereby granted
// without fee, provided that the above copyright notice appear in
// all copies and that both that copyright notice and this permission
// notice appear in supporting documentation, and that the name of
// the copyright holders not be used in advertising or publicity
// pertaining to distribution of the software without specific,
// written prior permission.  The copyright holders make no
// representations about the suitability of this software for any
// purpose.  It is provided "as is" without express or implied
// warranty.
//
// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
// THIS SOFTWARE.

package text_input

import (
	"sync"

	"github.com/rajveermalviya/go-wayland/client"
)

// ZwpTextInputV3 : text input
//
// The zwp_text_input_v3 interface represents text input and input methods
// associated with a seat. It provides enter/leave events to follow the
// text input focus for a seat.
//
// Requests are used to enable/disable the text-input object and set
// state information like surrounding and selected text or the content type.
// The information about the entered text is sent to the text-input object
// via the preedit_string and commit_string events.
//
// Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
// must not point to middle bytes inside a code point: they must either
// point to the first byte of a code point or to the end of the buffer.
// Lengths must be measured between two valid indices.
//
// Focus moving throughout surfaces will result in the emission of
// zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
// surface must commit zwp_text_input_v3.enable and
// zwp_text_input_v3.disable requests as the keyboard focus moves across
// editable and non-editable elements of the UI. Those two requests are not
// expected to be paired with each other, the compositor must be able to
// handle consecutive series of the same request.
//
// State is sent by the state requests (set_surrounding_text,
// set_content_type and set_cursor_rectangle) and a commit request. After an
// enter event or disable request all state information is invalidated and
// needs to be resent by the client.
type ZwpTextInputV3 struct {
	client.BaseProxy
	mu                            sync.RWMutex
	enterHandlers                 []ZwpTextInputV3EnterHandler
	leaveHandlers                 []ZwpTextInputV3LeaveHandler
	preeditStringHandlers         []ZwpTextInputV3PreeditStringHandler
	commitStringHandlers          []ZwpTextInputV3CommitStringHandler
	deleteSurroundingTextHandlers []ZwpTextInputV3DeleteSurroundingTextHandler
	doneHandlers                  []ZwpTextInputV3DoneHandler
}

// NewZwpTextInputV3 : text input
//
// The zwp_text_input_v3 interface represents text input and input methods
// associated with a seat. It provides enter/leave events to follow the
// text input focus for a seat.
//
// Requests are used to enable/disable the text-input object and set
// state information like surrounding and selected text or the content type.
// The information about the entered text is sent to the text-input object
// via the preedit_string and commit_string events.
//
// Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
// must not point to middle bytes inside a code point: they must either
// point to the first byte of a code point or to the end of the buffer.
// Lengths must be measured between two valid indices.
//
// Focus moving throughout surfaces will result in the emission of
// zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
// surface must commit zwp_text_input_v3.enable and
// zwp_text_input_v3.disable requests as the keyboard focus moves across
// editable and non-editable elements of the UI. Those two requests are not
// expected to be paired with each other, the compositor must be able to
// handle consecutive series of the same request.
//
// State is sent by the state requests (set_surrounding_text,
// set_content_type and set_cursor_rectangle) and a commit request. After an
// enter event or disable request all state information is invalidated and
// needs to be resent by the client.
func NewZwpTextInputV3(ctx *client.Context) *ZwpTextInputV3 {
	zwpTextInputV3 := &ZwpTextInputV3{}
	ctx.Register(zwpTextInputV3)
	return zwpTextInputV3
}

// Destroy : Destroy the wp_text_input
//
// Destroy the wp_text_input object. Also disables all surfaces enabled
// through this wp_text_input object.
//
func (i *ZwpTextInputV3) Destroy() error {
	err := i.Context().SendRequest(i, 0)
	return err
}

// Enable : Request text input to be enabled
//
// Requests text input on the surface previously obtained from the enter
// event.
//
// This request must be issued every time the active text input changes
// to a new one, including within the current surface. Use
// zwp_text_input_v3.disable when there is no longer any input focus on
// the current surface.
//
// Clients must not enable more than one text input on the single seat
// and should disable the current text input before enabling the new one.
// At most one instance of text input may be in enabled state per instance,
// Requests to enable the another text input when some text input is active
// must be ignored by compositor.
//
// This request resets all state associated with previous enable, disable,
// set_surrounding_text, set_text_change_cause, set_content_type, and
// set_cursor_rectangle requests, as well as the state associated with
// preedit_string, commit_string, and delete_surrounding_text events.
//
// The set_surrounding_text, set_content_type and set_cursor_rectangle
// requests must follow if the text input supports the necessary
// functionality.
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The changes must be applied by the compositor after issuing a
// zwp_text_input_v3.commit request.
//
func (i *ZwpTextInputV3) Enable() error {
	err := i.Context().SendRequest(i, 1)
	return err
}

// Disable : Disable text input on a surface
//
// Explicitly disable text input on the current surface (typically when
// there is no focus on any text entry inside the surface).
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request.
//
func (i *ZwpTextInputV3) Disable() error {
	err := i.Context().SendRequest(i, 2)
	return err
}

// SetSurroundingText : sets the surrounding text
//
// Sets the surrounding plain text around the input, excluding the preedit
// text.
//
// The client should notify the compositor of any changes in any of the
// values carried with this request, including changes caused by handling
// incoming text-input events as well as changes caused by other
// mechanisms like keyboard typing.
//
// If the client is unaware of the text around the cursor, it should not
// issue this request, to signify lack of support to the compositor.
//
// Text is UTF-8 encoded, and should include the cursor position, the
// complete selection and additional characters before and after them.
// There is a maximum length of wayland messages, so text can not be
// longer than 4000 bytes.
//
// Cursor is the byte offset of the cursor within text buffer.
//
// Anchor is the byte offset of the selection anchor within text buffer.
// If there is no selected text, anchor is the same as cursor.
//
// If any preedit text is present, it is replaced with a cursor for the
// purpose of this event.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial state for affected fields is empty, meaning that the text
// input does not support sending surrounding text. If the empty values
// get applied, subsequent attempts to change them may have no effect.
//
func (i *ZwpTextInputV3) SetSurroundingText(text string, cursor, anchor int32) error {
	err := i.Context().SendRequest(i, 3, text, cursor, anchor)
	return err
}

// SetTextChangeCause : indicates the cause of surrounding text change
//
// Tells the compositor why the text surrounding the cursor changed.
//
// Whenever the client detects an external change in text, cursor, or
// anchor posision, it must issue this request to the compositor. This
// request is intended to give the input method a chance to update the
// preedit text in an appropriate way, e.g. by removing it when the user
// starts typing with a keyboard.
//
// cause describes the source of the change.
//
// The value set with this request is double-buffered. It must be applied
// and reset to initial at the next zwp_text_input_v3.commit request.
//
// The initial value of cause is input_method.
//
func (i *ZwpTextInputV3) SetTextChangeCause(cause uint32) error {
	err := i.Context().SendRequest(i, 4, cause)
	return err
}

// SetContentType : set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some of
// the behavior.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request.
// Subsequent attempts to update them may have no effect. The values
// remain valid until the next committed enable or disable request.
//
// The initial value for hint is none, and the initial value for purpose
// is normal.
//
func (i *ZwpTextInputV3) SetContentType(hint, purpose uint32) error {
	err := i.Context().SendRequest(i, 5, hint, purpose)
	return err
}

// SetCursorRectangle : set cursor position
//
// Marks an area around the cursor as a x, y, width, height rectangle in
// surface local coordinates.
//
// Allows the compositor to put a window with word suggestions near the
// cursor, without obstructing the text being input.
//
// If the client is unaware of the position of edited text, it should not
// issue this request, to signify lack of support to the compositor.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial values describing a cursor rectangle are empty. That means
// the text input does not support describing the cursor area. If the
// empty values get applied, subsequent attempts to change them may have
// no effect.
//
func (i *ZwpTextInputV3) SetCursorRectangle(x, y, width, height int32) error {
	err := i.Context().SendRequest(i, 6, x, y, width, height)
	return err
}

// Commit : commit state
//
// Atomically applies state changes recently sent to the compositor.
//
// The commit request establishes and updates the state of the client, and
// must be issued after any changes to apply them.
//
// Text input state (enabled status, content purpose, content hint,
// surrounding text and change cause, cursor rectangle) is conceptually
// double-buffered within the context of a text input, i.e. between a
// committed enable request and the following committed enable or disable
// request.
//
// Protocol requests modify the pending state, as opposed to the current
// state in use by the input method. A commit request atomically applies
// all pending state, replacing the current state. After commit, the new
// pending state is as documented for each related request.
//
// Requests are applied in the order of arrival.
//
// Neither current nor pending state are modified unless noted otherwise.
//
// The compositor must count the number of commit requests coming from
// each zwp_text_input_v3 object and use the count as the serial in done
// events.
//
func (i *ZwpTextInputV3) Commit() error {
	err := i.Context().SendRequest(i, 7)
	return err
}

// ZwpTextInputV3ChangeCause : text change reason
//
// Reason for the change of surrounding text or cursor posision.
const (
	// ZwpTextInputV3ChangeCauseInputMethod : input method caused the change
	ZwpTextInputV3ChangeCauseInputMethod = 0
	// ZwpTextInputV3ChangeCauseOther : something else than the input method caused the change
	ZwpTextInputV3ChangeCauseOther = 1
)

// ZwpTextInputV3ContentHint : content hint
//
// Content hint is a bitmask to allow to modify the behavior of the text
// input.
const (
	// ZwpTextInputV3ContentHintNone : no special behavior
	ZwpTextInputV3ContentHintNone = 0x0
	// ZwpTextInputV3ContentHintCompletion : suggest word completions
	ZwpTextInputV3ContentHintCompletion = 0x1
	// ZwpTextInputV3ContentHintSpellcheck : suggest word corrections
	ZwpTextInputV3ContentHintSpellcheck = 0x2
	// ZwpTextInputV3ContentHintAutoCapitalization : switch to uppercase letters at the start of a sentence
	ZwpTextInputV3ContentHintAutoCapitalization = 0x4
	// ZwpTextInputV3ContentHintLowercase : prefer lowercase letters
	ZwpTextInputV3ContentHintLowercase = 0x8
	// ZwpTextInputV3ContentHintUppercase : prefer uppercase letters
	ZwpTextInputV3ContentHintUppercase = 0x10
	// ZwpTextInputV3ContentHintTitlecase : prefer casing for titles and headings (can be language dependent)
	ZwpTextInputV3ContentHintTitlecase = 0x20
	// ZwpTextInputV3ContentHintHiddenText : characters should be hidden
	ZwpTextInputV3ContentHintHiddenText = 0x40
	// ZwpTextInputV3ContentHintSensitiveData : typed text should not be stored
	ZwpTextInputV3ContentHintSensitiveData = 0x80
	// ZwpTextInputV3ContentHintLatin : just Latin characters should be entered
	ZwpTextInputV3ContentHintLatin = 0x100
	// ZwpTextInputV3ContentHintMultiline : the text input is multiline
	ZwpTextInputV3ContentHintMultiline = 0x200
)

// ZwpTextInputV3ContentPurpose : content purpose
//
// The content purpose allows to specify the primary purpose of a text
// input.
//
// This allows an input method to show special purpose input panels with
// extra characters or to disallow some characters.
const (
	// ZwpTextInputV3ContentPurposeNormal : default input, allowing all characters
	ZwpTextInputV3ContentPurposeNormal = 0
	// ZwpTextInputV3ContentPurposeAlpha : allow only alphabetic characters
	ZwpTextInputV3ContentPurposeAlpha = 1
	// ZwpTextInputV3ContentPurposeDigits : allow only digits
	ZwpTextInputV3ContentPurposeDigits = 2
	// ZwpTextInputV3ContentPurposeNumber : input a number (including decimal separator and sign)
	ZwpTextInputV3ContentPurposeNumber = 3
	// ZwpTextInputV3ContentPurposePhone : input a phone number
	ZwpTextInputV3ContentPurposePhone = 4
	// ZwpTextInputV3ContentPurposeUrl : input an URL
	ZwpTextInputV3ContentPurposeUrl = 5
	// ZwpTextInputV3ContentPurposeEmail : input an email address
	ZwpTextInputV3ContentPurposeEmail = 6
	// ZwpTextInputV3ContentPurposeName : input a name of a person
	ZwpTextInputV3ContentPurposeName = 7
	// ZwpTextInputV3ContentPurposePassword : input a password (combine with sensitive_data hint)
	ZwpTextInputV3ContentPurposePassword = 8
	// ZwpTextInputV3ContentPurposePin : input is a numeric password (combine with sensitive_data hint)
	ZwpTextInputV3ContentPurposePin = 9
	// ZwpTextInputV3ContentPurposeDate : input a date
	ZwpTextInputV3ContentPurposeDate = 10
	// ZwpTextInputV3ContentPurposeTime : input a time
	ZwpTextInputV3ContentPurposeTime = 11
	// ZwpTextInputV3ContentPurposeDatetime : input a date and time
	ZwpTextInputV3ContentPurposeDatetime = 12
	// ZwpTextInputV3ContentPurposeTerminal : input for a terminal
	ZwpTextInputV3ContentPurposeTerminal = 13
)

// ZwpTextInputV3EnterEvent : enter event
//
// Notification that this seat's text-input focus is on a certain surface.
//
// If client has created multiple text input objects, compositor must send
// this event to all of them.
//
// When the seat has the keyboard capability the text-input focus follows
// the keyboard focus. This event sets the current surface for the
// text-input object.
type ZwpTextInputV3EnterEvent struct {
	Surface *client.WlSurface
}

type ZwpTextInputV3EnterHandler interface {
	HandleZwpTextInputV3Enter(ZwpTextInputV3EnterEvent)
}

// AddEnterHandler : adds handler for ZwpTextInputV3EnterEvent
func (i *ZwpTextInputV3) AddEnterHandler(h ZwpTextInputV3EnterHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.enterHandlers = append(i.enterHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV3) RemoveEnterHandler(h ZwpTextInputV3EnterHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.enterHandlers {
		if e == h {
			i.enterHandlers = append(i.enterHandlers[:j], i.enterHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV3LeaveEvent : leave event
//
// Notification that this seat's text-input focus is no longer on a
// certain surface. The client should reset any preedit string previously
// set.
//
// The leave notification clears the current surface. It is sent before
// the enter notification for the new focus. After leave event, compositor
// must ignore requests from any text input instances until next enter
// event.
//
// When the seat has the keyboard capability the text-input focus follows
// the keyboard focus.
type ZwpTextInputV3LeaveEvent struct {
	Surface *client.WlSurface
}

type ZwpTextInputV3LeaveHandler interface {
	HandleZwpTextInputV3Leave(ZwpTextInputV3LeaveEvent)
}

// AddLeaveHandler : adds handler for ZwpTextInputV3LeaveEvent
func (i *ZwpTextInputV3) AddLeaveHandler(h ZwpTextInputV3LeaveHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.leaveHandlers = append(i.leaveHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV3) RemoveLeaveHandler(h ZwpTextInputV3LeaveHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.leaveHandlers {
		if e == h {
			i.leaveHandlers = append(i.leaveHandlers[:j], i.leaveHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV3PreeditStringEvent : pre-edit
//
// Notify when a new composing text (pre-edit) should be set at the
// current cursor position. Any previously set composing text must be
// removed. Any previously existing selected text must be removed.
//
// The argument text contains the pre-edit string buffer.
//
// The parameters cursor_begin and cursor_end are counted in bytes
// relative to the beginning of the submitted text buffer. Cursor should
// be hidden when both are equal to -1.
//
// They could be represented by the client as a line if both values are
// the same, or as a text highlight otherwise.
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial value of text is an empty string, and cursor_begin,
// cursor_end and cursor_hidden are all 0.
type ZwpTextInputV3PreeditStringEvent struct {
	Text        string
	CursorBegin int32
	CursorEnd   int32
}

type ZwpTextInputV3PreeditStringHandler interface {
	HandleZwpTextInputV3PreeditString(ZwpTextInputV3PreeditStringEvent)
}

// AddPreeditStringHandler : adds handler for ZwpTextInputV3PreeditStringEvent
func (i *ZwpTextInputV3) AddPreeditStringHandler(h ZwpTextInputV3PreeditStringHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.preeditStringHandlers = append(i.preeditStringHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV3) RemovePreeditStringHandler(h ZwpTextInputV3PreeditStringHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.preeditStringHandlers {
		if e == h {
			i.preeditStringHandlers = append(i.preeditStringHandlers[:j], i.preeditStringHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV3CommitStringEvent : text commit
//
// Notify when text should be inserted into the editor widget. The text to
// commit could be either just a single character after a key press or the
// result of some composing (pre-edit).
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial value of text is an empty string.
type ZwpTextInputV3CommitStringEvent struct {
	Text string
}

type ZwpTextInputV3CommitStringHandler interface {
	HandleZwpTextInputV3CommitString(ZwpTextInputV3CommitStringEvent)
}

// AddCommitStringHandler : adds handler for ZwpTextInputV3CommitStringEvent
func (i *ZwpTextInputV3) AddCommitStringHandler(h ZwpTextInputV3CommitStringHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.commitStringHandlers = append(i.commitStringHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV3) RemoveCommitStringHandler(h ZwpTextInputV3CommitStringHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.commitStringHandlers {
		if e == h {
			i.commitStringHandlers = append(i.commitStringHandlers[:j], i.commitStringHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV3DeleteSurroundingTextEvent : delete surrounding text
//
// Notify when the text around the current cursor position should be
// deleted.
//
// Before_length and after_length are the number of bytes before and after
// the current cursor index (excluding the selection) to delete.
//
// If a preedit text is present, in effect before_length is counted from
// the beginning of it, and after_length from its end (see done event
// sequence).
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial values of both before_length and after_length are 0.
type ZwpTextInputV3DeleteSurroundingTextEvent struct {
	BeforeLength uint32
	AfterLength  uint32
}

type ZwpTextInputV3DeleteSurroundingTextHandler interface {
	HandleZwpTextInputV3DeleteSurroundingText(ZwpTextInputV3DeleteSurroundingTextEvent)
}

// AddDeleteSurroundingTextHandler : adds handler for ZwpTextInputV3DeleteSurroundingTextEvent
func (i *ZwpTextInputV3) AddDeleteSurroundingTextHandler(h ZwpTextInputV3DeleteSurroundingTextHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.deleteSurroundingTextHandlers = append(i.deleteSurroundingTextHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV3) RemoveDeleteSurroundingTextHandler(h ZwpTextInputV3DeleteSurroundingTextHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.deleteSurroundingTextHandlers {
		if e == h {
			i.deleteSurroundingTextHandlers = append(i.deleteSurroundingTextHandlers[:j], i.deleteSurroundingTextHandlers[j+1:]...)
			break
		}
	}
}

// ZwpTextInputV3DoneEvent : apply changes
//
// Instruct the application to apply changes to state requested by the
// preedit_string, commit_string and delete_surrounding_text events. The
// state relating to these events is double-buffered, and each one
// modifies the pending state. This event replaces the current state with
// the pending state.
//
// The application must proceed by evaluating the changes in the following
// order:
//
// 1. Replace existing preedit string with the cursor.
// 2. Delete requested surrounding text.
// 3. Insert commit string with the cursor at its end.
// 4. Calculate surrounding text to send.
// 5. Insert new preedit text in cursor position.
// 6. Place cursor inside preedit text.
//
// The serial number reflects the last state of the zwp_text_input_v3
// object known to the compositor. The value of the serial argument must
// be equal to the number of commit requests already issued on that object.
// When the client receives a done event with a serial different than the
// number of past commit requests, it must proceed as normal, except it
// should not change the current state of the zwp_text_input_v3 object.
type ZwpTextInputV3DoneEvent struct {
	Serial uint32
}

type ZwpTextInputV3DoneHandler interface {
	HandleZwpTextInputV3Done(ZwpTextInputV3DoneEvent)
}

// AddDoneHandler : adds handler for ZwpTextInputV3DoneEvent
func (i *ZwpTextInputV3) AddDoneHandler(h ZwpTextInputV3DoneHandler) {
	if h == nil {
		return
	}

	i.mu.Lock()
	i.doneHandlers = append(i.doneHandlers, h)
	i.mu.Unlock()
}

func (i *ZwpTextInputV3) RemoveDoneHandler(h ZwpTextInputV3DoneHandler) {
	i.mu.Lock()
	defer i.mu.Unlock()

	for j, e := range i.doneHandlers {
		if e == h {
			i.doneHandlers = append(i.doneHandlers[:j], i.doneHandlers[j+1:]...)
			break
		}
	}
}

func (i *ZwpTextInputV3) Dispatch(event *client.Event) {
	switch event.Opcode {
	case 0:
		i.mu.RLock()
		if len(i.enterHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV3EnterEvent{
			Surface: event.Proxy(i.Context()).(*client.WlSurface),
		}

		i.mu.RLock()
		for _, h := range i.enterHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV3Enter(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 1:
		i.mu.RLock()
		if len(i.leaveHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV3LeaveEvent{
			Surface: event.Proxy(i.Context()).(*client.WlSurface),
		}

		i.mu.RLock()
		for _, h := range i.leaveHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV3Leave(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 2:
		i.mu.RLock()
		if len(i.preeditStringHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV3PreeditStringEvent{
			Text:        event.String(),
			CursorBegin: event.Int32(),
			CursorEnd:   event.Int32(),
		}

		i.mu.RLock()
		for _, h := range i.preeditStringHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV3PreeditString(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 3:
		i.mu.RLock()
		if len(i.commitStringHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV3CommitStringEvent{
			Text: event.String(),
		}

		i.mu.RLock()
		for _, h := range i.commitStringHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV3CommitString(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 4:
		i.mu.RLock()
		if len(i.deleteSurroundingTextHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV3DeleteSurroundingTextEvent{
			BeforeLength: event.Uint32(),
			AfterLength:  event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.deleteSurroundingTextHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV3DeleteSurroundingText(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	case 5:
		i.mu.RLock()
		if len(i.doneHandlers) == 0 {
			i.mu.RUnlock()
			break
		}
		i.mu.RUnlock()

		e := ZwpTextInputV3DoneEvent{
			Serial: event.Uint32(),
		}

		i.mu.RLock()
		for _, h := range i.doneHandlers {
			i.mu.RUnlock()

			h.HandleZwpTextInputV3Done(e)

			i.mu.RLock()
		}
		i.mu.RUnlock()
	}
}

// ZwpTextInputManagerV3 : text input manager
//
// A factory for text-input objects. This object is a global singleton.
type ZwpTextInputManagerV3 struct {
	client.BaseProxy
}

// NewZwpTextInputManagerV3 : text input manager
//
// A factory for text-input objects. This object is a global singleton.
func NewZwpTextInputManagerV3(ctx *client.Context) *ZwpTextInputManagerV3 {
	zwpTextInputManagerV3 := &ZwpTextInputManagerV3{}
	ctx.Register(zwpTextInputManagerV3)
	return zwpTextInputManagerV3
}

// Destroy : Destroy the wp_text_input_manager
//
// Destroy the wp_text_input_manager object.
//
func (i *ZwpTextInputManagerV3) Destroy() error {
	err := i.Context().SendRequest(i, 0)
	return err
}

// GetTextInput : create a new text input object
//
// Creates a new text-input object for a given seat.
//
func (i *ZwpTextInputManagerV3) GetTextInput(seat *client.WlSeat) (*ZwpTextInputV3, error) {
	id := NewZwpTextInputV3(i.Context())
	err := i.Context().SendRequest(i, 1, id, seat)
	return id, err
}
